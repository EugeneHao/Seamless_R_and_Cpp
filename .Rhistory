for (i in seq_len(n)) {
third <- first + second
first <- second
second <- third
}
return(first)
}
fibRiter(20)
fibRiter<-function(n){
first <- 0
second <- 1
third <- 0
for (i in seq_len(n)) {
third <- first + second
first <- second
second <- third
}
return(first)
}
fibRcppIter<-cxxfunction(signature(xs="int"), plugin="Rcpp",
body='
int n = Rcpp::as<int>(xs);
double first = 0;
double second = 1;
double third = 0;
for (int i=0; i<n; i++) {
third = first + second;
first = second;
second = third;
}
return Rcpp::wrap(first);
')
rbenchmark::benchmark(mfibR(30), mfibRcpp(30), fibRiter(30), fibRcppIter(30))
rbenchmark::benchmark(mfibR(50), mfibRcpp(50), fibRiter(50), fibRcppIter(50))
rbenchmark::benchmark(mfibR(100), mfibRcpp(100), fibRiter(100), fibRcppIter(100))
bookdown::render_book()
##parameter and error terms used through out
a <- matrix(c(0.5,0.1,0.1,0.5),nrow=2)
u <- matrix(rnorm(10000),ncol=2)
##Letâ€™s start with the Rversion
rSim <- function(coeff, errors) {
simdata <- matrix(0, nrow(errors), ncol(errors))
for (row in 2:nrow(errors)) {
simdata[row,] = coeff %*% simdata[(row-1),] + errors[row,]
}
return(simdata)
}
rData <- rSim(a, u)
dim(rData)
plot(rData[,1])
plot(rData[,1], rData[,2])
code <- '
arma::mat coeff = Rcpp::as<arma::mat>(a);
''
'
code <- '
arma::mat coeff = Rcpp::as<arma::mat>(a);
arma::mat errors = Rcpp::as<arma::mat>(u);
int m = errors.n_rows;
int n = errors.n_cols;
arma::mat simdata(m,n);
simdata.row(0) = arma::zeros<arma::mat>(1,n);
for (int row=1; row<m; row++) {
simdata.row(row) = simdata.row(row-1)*trans(coeff) + errors.row(row);
}
return Rcpp::wrap(simdata);
'
## create the compiled function
rcppSim <- cxxfunction(signature(a="numeric",u="numeric"),
code, plugin="RcppArmadillo")
rcppData <- rcppSim(a,u)              # generated by C++ code
stopifnot(all.equal(rData, rcppData)) # checking results
stopifnot(all.equal(rData, rcppData))
head(rData)
head(rcppData)
?cxxfunction
bookdown::render_book()
bookdown::render_book()
bookdown::render_book()
bookdown::render_book()
bookdown::publish_book()
bookdown::render_book()
bookdown::publish_book()
library(Rcpp)
library(inline)
library(RcppArmadillo)
setwd("~/Documents/GitHub/Seamless_R_and_Cpp/")
src<-'
Rcpp::NumericVector xa(a);
Rcpp::NumericVector xb(b);
int n_xa = xa.size(), n_xb = xb.size();
Rcpp::NumericVector xab(n_xa + n_xb - 1);
for(int i=0; i<n_xa; i++)
for(int j=0; j<n_xb; j++)
xab[i + j] += xa[i] * xb[j];
return xab;
'
fun <- cxxfunction(signature(a="numeric", b="numeric"),
src,plugin="Rcpp")
fun( 1:4, 2:5 )
fun <- rcpp(signature(a="numeric", b="numeric"), src)
fun( 1:4, 2:5 )
fun <- cxxfunction(signature(a="numeric", b="numeric"),
src,plugin="Rcpp", verbose = T)
fun <- cxxfunction(signature(a="numeric", b="numeric"),
src,plugin="Rcpp")
3L
inc<-'
template <typename T>
class square : public std::unary_function<T,T> {
public:
T operator()( T t) const { return t*t ;}
};
'
src <- '
double x = Rcpp::as<double>(xs);
int i = Rcpp::as<int>(is);
square<double> sqdbl;
square<int> sqint;
Rcpp::DataFrame df =
Rcpp::DataFrame::create(Rcpp::Named("x", sqdbl(x)),
Rcpp::Named("i", sqint(i)));
return df;
'
fun <- cxxfunction(signature(xs="numeric", is="integer"),
body=src,include=inc,plugin="Rcpp")
fun(2.2, 3L)
fun(2.2, 3)
src <-  '
Rcpp::NumericVector yr(ys) ;
Rapp::NumericMatrix Xr(Xs) ;
int n = Xr.nrow(), k = Xr.ncol() ;
arma::mat X(Xr.begin(), n, k, false) ;
arma::colvec y(yr.begin(), yr.size (), false);
arma::colvec coef = arma::solve (X, y);    // fit y ~ X
arma::colvec res = y - X*coef;   // residuals
double s2 = std::inner_product(res.begin(), res.end(),
res.begin(), double())/(n - k);
arma::colvec se = arma::sart(s2 *
arma::diagvec(arma::inv(arma::trans(X)*X)));
return Rcpp::List::create(Rcpp::Named("coef")= coef,
Rcpp::Named("se")  = se,
Rcpp::Named("df")  = n-k);
'
fun<-cxxfunction(signature(ys="numeric",Xs="numeric"),
src, plugin="RcppArmadillo")
src <-  '
Rcpp::NumericVector yr(ys) ;
Rapp::NumericMatrix Xr(Xs) ;
int n = Xr.nrow(), k = Xr.ncol() ;
arma::mat X(Xr.begin(), n, k, false) ;
arma::colvec y(yr.begin(), yr.size (), false);
arma::colvec coef = arma::solve (X, y);    // fit y ~ X
arma::colvec res = y - X*coef;   // residuals
double s2 = std::inner_product(res.begin(), res.end(),
res.begin(), double())/(n - k);
arma::colvec se = arma::sqrt(s2 *
arma::diagvec(arma::inv(arma::trans(X)*X)));
return Rcpp::List::create(Rcpp::Named("coef")= coef,
Rcpp::Named("se")  = se,
Rcpp::Named("df")  = n-k);
'
fun<-cxxfunction(signature(ys="numeric", Xs="numeric"),
src, plugin="RcppArmadillo")
fun<-cxxfunction(signature(ys="numeric", Xs="numeric"),
src, plugin="RcppArmadillo")
src <-  '
Rcpp::NumericVector yr(ys) ;
Rcpp::NumericMatrix Xr(Xs) ;
int n = Xr.nrow(), k = Xr.ncol() ;
arma::mat X(Xr.begin(), n, k, false) ;
arma::colvec y(yr.begin(), yr.size (), false);
arma::colvec coef = arma::solve (X, y);    // fit y ~ X
arma::colvec res = y - X*coef;   // residuals
double s2 = std::inner_product(res.begin(), res.end(),
res.begin(), double())/(n - k);
arma::colvec se = arma::sqrt(s2 *
arma::diagvec(arma::inv(arma::trans(X)*X)));
return Rcpp::List::create(Rcpp::Named("coef")= coef,
Rcpp::Named("se")  = se,
Rcpp::Named("df")  = n-k);
'
fun<-cxxfunction(signature(ys="numeric", Xs="numeric"),
src, plugin="RcppArmadillo")
X <- matrix(rnorm(100), nrow = 50)
y <- X %*% 1:2 + rnorm(50)
fun(ys = y, Xs = X)
src <-  '
Rcpp::NumericVector yr(ys) ;
Rcpp::NumericMatrix Xr(Xs) ;
int n = Xr.nrow(), k = Xr.ncol();
arma::mat X(Xr.begin(), n, k, false) ;
arma::colvec y(yr.begin(), yr.size (), false);
arma::colvec coef = arma::solve(X, y);    // fit y ~ X
arma::colvec res = y - X*coef;   // residuals
double s2 = std::inner_product(res.begin(), res.end(),
res.begin(), double())/(n - k);
arma::colvec se = arma::sqrt(s2 *
arma::diagvec(arma::inv(arma::trans(X)*X)));
return Rcpp::List::create(Rcpp::Named("coef", coef),
Rcpp::Named("se")  = se,
Rcpp::Named("df")  = n-k);
'
fun<-cxxfunction(signature(ys="numeric", Xs="numeric"),
src, plugin="RcppArmadillo")
X <- matrix(rnorm(100), nrow = 50)
y <- X %*% 1:2 + rnorm(50)
fun(ys = y, Xs = X)
install.packages("RcppGSL")
library(RcppGSL)
bookdown::render_book()
bookdown::render_book()
setwd("~/Documents/GitHub/Seamless_R_and_Cpp")
src <- '
int dx = Rcpp::as<int>(x);
if( dx > 10 )
throw std::range_error("too big");
return Rcpp::wrap( dx * dx);
')
src <- '
int dx = Rcpp::as<int>(x);
if( dx > 10 )
throw std::range_error("too big");
return Rcpp::wrap( dx * dx);
'
fun <- cxxfunction(x="integer", body=src, plugin="Rcpp")
fun <- cxxfunction(x="integer", body=src, plugin="Rcpp")
fun <- cxxfunction(x="int", body=src, plugin="Rcpp")
fun <- cxxfunction(signature(x="int"), body=src, plugin="Rcpp")
fun(3)
fun(13)
fun("df")
bookdown::render_book()
fun(13)
bookdown::render_book()
bookdown::render_book()
bookdown::publish_book()
bookdown::render_book()
bookdown::publish_book()
install.packages("rjags")
library(rjags)
model = "
model
{
y ~ dbin(theta,n)   # notice p then n
theta ~ dbeta(a,b)
}"
dat = list(n=10, y=3, a=1, b=1)
m = jags.model(textConnection(model), dat)
r = coda.samples (m, "theta", n.iter=1000)
summary(r)
plot(r)
install.packages("coda")
library(rjags)
library(rjags)
library(rstan)
model = "
data {
int<lower=0> n; # define range and type
int<lower=0> a; # and notice semicolons
int<lower=0> b;
int<lower=0, upper=n> y;
}
parameters {
real<lower=0, upper=1> theta;
}
model {
y ~ binomial(n, theta) ;
theta ~ beta(a, b) ;
}
"
dat = list(n=10, y=3, a=1, b=1)
m = stan_model(model_code = model) # Only needs to be done once
m
model = "
data {
int<lower=0> n; // define range and type
int<lower=0> a; // and notice semicolons
int<lower=0> b;
int<lower=0, upper=n> y;
}
parameters {
real<lower=0, upper=1> theta;
}
model {
y ~ binomial(n, theta) ;
theta ~ beta(a, b) ;
}
"
dat = list(n=10, y=3, a=1, b=1)
m = stan_model(model_code = model) # Only needs to be done once
r = sampling(m, data = dat)
r
plot(r)
shiny::runApp('~/Dropbox/My/My App/TravelApp')
runApp('~/Dropbox/My/My App/TravelApp')
runApp('~/Dropbox/My/My App/TravelApp')
src <- '
Rcpp::IntegerVector vec(vx) ;
int prod = 1 ;
for (int i=0; i<vec.size(); i++) {
prod *= vec[i] ;
}
return Rcpp::wrap(prod) ;
'
fun < cxxfunction(signature(vx = "integer"), src, plugin="Rcpp")
fun <- cxxfunction(signature(vx = "integer"), src, plugin="Rcpp")
fun(1:10) # creates integer vector
prod(10)
prod(1:10)
# through Standard Template Library
src2 <- '
Rcpp::IntegerVector vec(vx) ;
int prod = std::accumulate(vec.begin(), vec.end(), 1, std::multiplies<int>());
return Rcpp::wrap(prod) ;
'
fun2 <- cxxfunction(signature(vx = "integer"), src2, plugin="Rcpp")
fun2(1:10)
# through Standard Template Library
src2 <- '
Rcpp::IntegerVector vec(vx) ;
int prod = std::accumulate(vec.begin(), vec.end(), 2, std::multiplies<int>());
return Rcpp::wrap(prod) ;
'
fun2 <- cxxfunction(signature(vx = "integer"), src2, plugin="Rcpp")
fun2 <- cxxfunction(signature(vx = "integer"), src2, plugin="Rcpp")
fun2(1:10)
7257600/2
fun(seq(1.0, 1.9, by=0.1))
fun2(seq(1.0, 1.9, by=0.1))
seq(1.0, 1.9, by=0.1)
LETTERS[1:10]
fun(LETTERS[1:10])
src3 <- '
Rcpp::IntegerVector vec(vx) ;
int prod = std::accumulate(vec.begin(), vec.end(), 1, std::multiplies<double>());
return Rcpp::wrap(prod) ;
'
fun3 <- cxxfunction(signature(vx = "double"), src3, plugin="Rcpp")
fun3(seq(1.0, 1.9, by = 0.1))
src3 <- '
Rcpp::DoubleVector vec(vx) ;
int prod = std::accumulate(vec.begin(), vec.end(), 1, std::multiplies<double>());
return Rcpp::wrap(prod) ;
'
fun3 <- cxxfunction(signature(vx = "double"), src3, plugin="Rcpp")
fun3(seq(1.0, 1.9, by = 0.1))
src3 <- '
Rcpp::NumericVector vec(vx) ;
double prod = std::accumulate(vec.begin(), vec.end(), 1, std::multiplies<double>());
return Rcpp::wrap(prod) ;
'
fun3 <- cxxfunction(signature(vx = "double"), src3, plugin="Rcpp")
fun3(seq(1.0, 1.9, by = 0.1))
src3 <- '
Rcpp::NumericVector vec(vx) ;
double prod = std::accumulate(vec.begin(), vec.end(), 1, std::multiplies<double>());
return Rcpp::wrap(prod) ;
'
fun3 <- cxxfunction(signature(vx = "numeric"), src3, plugin="Rcpp")
fun3(seq(1.0, 1.9, by = 0.1))
fun3(1:10)
src3 <- '
Rcpp::NumericVector vec(vx) ;
double prod = std::accumulate(vec.begin(), vec.end(), 1.0, std::multiplies<double>());
return Rcpp::wrap(prod) ;
'
fun3 <- cxxfunction(signature(vx = "numeric"), src3, plugin="Rcpp")
fun3(seq(1.0, 1.9, by = 0.1))
# modify the code 2
src3 <- '
Rcpp::NumericVector ved(vx) ;
double prod = std::accumulate(ved.begin(), ved.end(), 1.0, std::multiplies<double>());
return Rcpp::wrap(prod) ;
'
fun3 <- cxxfunction(signature(vx = "numeric"), src3, plugin="Rcpp")
fun3(seq(1.0, 1.9, by = 0.1))
prod(seq(1.0, 1.9, by = 0.1))
src <- '
Rcpp::NumericVector vec(vx);
double p = Rcpp::as<double>(dd);
double sum = 0.0;
for(int i = 0; i< vec.size(); i++) {
sum += pow(vec[i], p);
}
return Rcpp::wrap(sum);
'
fun <- cxxfunction(signature(vx="numeric",dd="numeric"),
src, plugin = "Rcpp")
fun(1:4, 2)
fun(1:4, 2.2)
scr <- "
Rcpp::NumericVector invec(vx);
Rcpp::NumericVector outvec = Rcpp::clone(vx);
for(int i = 0; i < invec.size(); i++) {
outvec[i] = log(invec[i]);
}
return outvec;
"
fun <- cxxfunction(signature(vx="numeric"),
scr, plugin = "Rcpp")
fun(1:3)
scr <- "
Rcpp::NumericVector invec(vx);
Rcpp::NumericVector outvec(vx);
for(int i = 0; i < invec.size(); i++) {
outvec[i] = log(invec[i]);
}
return outvec;
"
scr_clone <- "
Rcpp::NumericVector invec(vx);
Rcpp::NumericVector outvec = Rcpp::clone(vx);
for(int i = 0; i < invec.size(); i++) {
outvec[i] = log(invec[i]);
}
return outvec;
"
fun <- cxxfunction(signature(vx="numeric"), scr, plugin = "Rcpp")
fun_clone <- cxxfunction(signature(vx="numeric"), scr_clone, plugin = "Rcpp")
x = y = 1:3
cbind(x, fun(x), y, fun_clone(y))
x = 1:3; y = 1:3
cbind(x, fun(x), y, fun_clone(y))
scr <- "
Rcpp::NumericVector invec(vx);
Rcpp::NumericVector outvec(vx);
for(int i = 0; i < invec.size(); i++) {
outvec[i] = log(invec[i]);
}
return outvec;
"
fun <- cxxfunction(signature(vx="numeric"), scr, plugin = "Rcpp")
x
cbind(x, fun(x))
x <- 1:3; y <- 1:3
cbind(x, fun(x), y, fun_clone(y))
fun <- cxxfunction(signature(vx="numeric"), scr, plugin = "Rcpp")
x <- seq(1.0, 3.0, by = 1)
cbind(x, fun(x))
x <- 1:3
x
cbind(x, fun(x))
x = seq(1, 2, by = 0.1)
cbind(x, fun(x))
x = y = seq(1, 2, by = 0.1)
cbind(x, fun(x), y, fun_clone(y))
x <- seq(1, 2, by = 0.1); y <- seq(1, 2, by = 0.1)
cbind(x, fun(x), y, fun_clone(y))
x <- seq(1, 1.5, by = 0.1); y <- seq(1, 1.5, by = 0.1)
cbind(x, fun(x), y, fun_clone(y))
scr_simple <- "
Rcpp::NumericVector invec(vx);
Rcpp::NumericVector outvec = log(invec);
return outvec;
"
fun_simple <- cxxfunction(signature(vx="numeric"), scr_simple, plugin = "Rcpp")
x <- seq(1, 1.5, by = 0.1)
cbind(x, fun_simple(x))
p = 240000
for(i in 1:360)
{
p = p * (1 + 0.05/12) - 1288
print(p)
}
p = 240000
for(i in 1:360)
{
p = p * (1 + 0.05/12) - 1289
print(p)
}
2400000 / (1/1.005 * (1 - (1/1.005)^360)/(1 - 1/1.005))
240000 / (1/1.005 * (1 - (1/1.005)^360)/(1 - 1/1.005))
240000 / (  (1 - (1/1.005)^360)/0.005)
5000 * ((1 - (1/1.005)^36)/0.005)
(240000 - 5000 * ((1 - (1/1.005)^36)/0.005))
p = 240000
for(i in 1:36)
{
p = p * (1 + 0.05/12) - 5000
print(p)
}
p = 240000
for(i in 1:36)
{
p = p * (1 + 0.06/12) - 5000
print(p)
}
(240000 - 5000 * ((1 - (1/1.005)^36)/0.005))
p = 240000
for(i in 1:60)
{
p = p * (1 + 0.06/12) - 5000
print(p)
}
p = 240000
for(i in 1:55)
{
p = p * (1 + 0.06/12) - 5000
print(p)
}
(240000 - 5000 * ((1 - (1/1.005)^55)/0.005))
(240000 - 5000 * ((1 - (1/1.005)^36)/0.005))
p = 240000
for(i in 1:36)
{
p = p * (1 + 0.06/12) - 5000 # zonge
print(p)
}
(240000 - 5000 * ((1 - (1/1.005)^35)/0.005))
(240000 - 5000 * ((1 - (1/1.005)^36)/0.005)) * 1.005^36
240000 * 1.005^36 - 5000 * (1.005^36 - 1)/0.005
