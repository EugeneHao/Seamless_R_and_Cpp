[["index.html", "Notebook of Seamless R and C++ Integration with Rcpp Chapter 1 Introduction", " Notebook of Seamless R and C++ Integration with Rcpp Hao Sun 2022-05-29 Chapter 1 Introduction The author makes some notes for Seamless R and C++ Integration with Rcpp written by Dirk Eddelbuettel in this notebook. This book is only for the author’s personal use only. "],["a-gentle-introduction-to-rcpp.html", "Chapter 2 A Gentle Introduction to Rcpp 2.1 Background: From R to C++ 2.2 A First Example 2.3 A Second Example", " Chapter 2 A Gentle Introduction to Rcpp 2.1 Background: From R to C++ xx &lt;- faithful$eruptions fit1 &lt;- density(xx) fit2 &lt;- replicate(1000, { x &lt;- sample(xx, replace=TRUE); density(x, from=min(fit1$x), to=max(fit1$x))$y }) fit3 &lt;- apply(fit2, 1, quantile, c(0.025,0.975)) plot(fit1, ylim=range(fit3)) polygon(x = c(fit1$x, rev(fit1$x)), y = c(fit3[1,], rev(fit3[2,])), col=&#39;grey&#39;, border=F) lines(fit1) Note: use replicate to reproduce some complicate function use polygon to plot confidence interval of a function and fill the polygon by grey. 2.2 A First Example The Fibonacci sequence \\(F_n\\) is defined by \\(F_n = F_{n-1} + F_{n-2}\\) with 2 initial conditions \\(F_0 = 0\\) and \\(F_1 = 1\\). R solution fibR &lt;- function(n) { if (n == 0) return(0) if (n == 1) return(1) return (fibR(n - 1) + fibR(n - 2)) } C++ solution # require Rcpp, inline incltxt &lt;- &#39; int fibonacci(const int x) { if (x == 0) return(0); if (x == 1) return(1); return fibonacci(x - 1) + fibonacci(x - 2); } &#39; fibRcpp &lt;- cxxfunction(signature(xs=&quot;int&quot;), plugin=&quot;Rcpp&quot;, incl=incltxt, body=&#39; int x = Rcpp::as&lt;int&gt;(xs) ; return Rcpp::wrap( fibonacci(x) ) ; &#39;) Note: This uses two key Rcpp tools, the converter functions as and wrap. as is used to convert the incoming argument xs from SEXP to integer. wrap converts the integer result in the integer variable x to the SEXP type. In incltxt, we define a C++ function fibonacci. cxxfunction: is used to turn code supplied as a text variable into an executable function. rbenchmark::benchmark(fibR(20), fibRcpp(20)) ## test replications elapsed relative user.self sys.self user.child sys.child ## 1 fibR(20) 100 0.461 230.5 0.454 0.007 0 0 ## 2 fibRcpp(20) 100 0.002 1.0 0.002 0.000 0 0 Using Rcpp Attributes One can simply declare certain “attributes,” notably whether a function is to be exported for use from R or from another C++ function (or both). One can declare dependencies whose resolution still relies on the plugin framework provided by inline. # in c1.2.cpp: # #include &lt;Rcpp.h&gt; # using namespace Rcpp; # # // [[Rcpp::export]] # int fibonacci(const int x) { # if (x&lt; 2) # return x; # else # return (fibonacci(x - 1)) + fibonacci(x - 2); # } sourceCpp(&quot;c++/c1.2.cpp&quot;) fibonacci(20) ## [1] 6765 Note: The [[Rcpp::export]] attribute preceds the function definition. The sourceCpp() reads the code from the given source file, parses it for the relevant attributes, and creates the required wrappers before calling R to compile and link just like inline does. A second R solution One elegant solution to retain the basic recursive structure of the algorithm with- out incurring the cost of repeated computation of the same value is provided by a method called memoization. mfibR &lt;- local({ memo &lt;- c(1, 1, rep(NA, 1000)) f &lt;- function(x) { if (x == 0) return(0) if (x &lt; 0) return(NA) if (x &gt; length(memo)) stop(&quot;x too big for implementation&quot;) if (!is.na(memo[x])) return(memo[x]) ans &lt;- f(x-2) + f(x-1) memo[x] &lt;&lt;- ans ans } }) If a value for argument n has already been encountered, it is used. Otherwise, it is computed and stored in vector memo. This ensures that the recursive function is called exactly once for each possible value of n.  Note: local function and &lt;&lt;- run mfibR(x) A second C++ solution mincltxt&lt;- &#39; #include &lt;algorithm&gt; #include &lt;vector&gt; #include &lt;stdexcept&gt; #include &lt;cmath&gt; #include &lt;iostream&gt; class Fib { public: Fib(unsigned int n = 1000) { memo.resize(n); // reserve n elements std::fill( memo.begin(), memo.end(), NAN ); // set to NaN memo[0] = 0.0; // initialize for memo[1] = 1.0; // n=0 and n=1 } double fibonacci(int x) { if (x &lt; 0) // guard against bad input return ( (double) NAN ); if (x &gt;= (int) memo.size() ) throw std::range_error(\\&quot;x too large for implementation\\&quot;); if ( ! ::isnan(memo[x])) return (memo[x]) ; // if exist, reuse values // build precomputed value via recursion memo[x] = fibonacci(x-2) + fibonacci(x-1) ; return ( memo[x] ) ; // and return } private: std::vector&lt; double &gt; memo ; // internal memory for precomp. }; &#39; mfibRcpp &lt;- cxxfunction(signature(xs=&quot;int&quot;), plugin=&quot;Rcpp&quot;, includes=mincltxt, body=&#39; int x = Rcpp::as&lt;int&gt;(xs); Fib f; return Rcpp::wrap( f.fibonacci(x-1) ); &#39;) We define a very simple C++ class Fib with three elements: + A constructor which is called once upon initialization. + A single public member function which computes Fn. + A private data vector holding the memoization values. rbenchmark::benchmark(fibRcpp(30), mfibR(30), mfibRcpp(30)) ## test replications elapsed relative user.self sys.self user.child sys.child ## 1 fibRcpp(30) 100 0.227 NA 0.226 0 0 0 ## 2 mfibR(30) 100 0.001 NA 0.000 0 0 0 ## 3 mfibRcpp(30) 100 0.000 NA 0.000 0 0 0 A third R solution We can also compute \\(F_n\\) using iterative approach. The iterative solution improves further on the approach using memoization as it requires neither stateful memory nor recursion. fibRiter&lt;-function(n){ first &lt;- 0 second &lt;- 1 third &lt;- 0 for (i in seq_len(n)) { third &lt;- first + second first &lt;- second second &lt;- third } return(first) } A third C++ solution fibRcppIter&lt;-cxxfunction(signature(xs=&quot;int&quot;), plugin=&quot;Rcpp&quot;, body=&#39; int n = Rcpp::as&lt;int&gt;(xs); double first = 0; double second = 1; double third = 0; for (int i=0; i&lt;n; i++) { third = first + second; first = second; second = third; } return Rcpp::wrap(first); &#39;) Note: From this example, we do not need to write a Cpp function separately. We can put the Cpp function in the body argument of cxxfunction. rbenchmark::benchmark(mfibR(100), mfibRcpp(100), fibRiter(100), fibRcppIter(100)) ## test replications elapsed relative user.self sys.self user.child sys.child ## 4 fibRcppIter(100) 100 0.000 NA 0.001 0.000 0 0 ## 3 fibRiter(100) 100 0.000 NA 0.000 0.000 0 0 ## 1 mfibR(100) 100 0.002 NA 0.001 0.001 0 0 ## 2 mfibRcpp(100) 100 0.000 NA 0.001 0.000 0 0 2.3 A Second Example Problem Setting The context of the example is a vector autoregressive process of order one for two variables, or in formal notation a VAR(1). More generally, a VAR model consists of a number \\(K\\) of endogenous variable \\(\\mathbf{x}_t\\). A VAR(p) process is then defined by a series of coefficient matrices \\(A_j\\) with \\(j\\in 1, \\ldots, p\\) such that \\[ \\mathbf{x}_t = A_1 \\mathbf{x}_{t-1} + \\ldots + A_p \\mathbf{x}_{t-p} + \\mathbf{u}_t \\] For example, we are considering the simplest case of two-dimensional VAR of order one, i.e. \\(\\mathbf{x}_t = A_1 \\mathbf{x}_{t-1} + \\mathbf{u}_t\\). R solution ##parameter and error terms used through out a &lt;- matrix(c(0.5,0.1,0.1,0.5),nrow=2) u &lt;- matrix(rnorm(10000),ncol=2) ##Let’s start with the Rversion rSim &lt;- function(coeff, errors) { simdata &lt;- matrix(0, nrow(errors), ncol(errors)) for (row in 2:nrow(errors)) { simdata[row,] = coeff %*% simdata[(row-1),] + errors[row,] } return(simdata) } rData &lt;- rSim(a, u) C++ Solution In this solution, we use RcppArmadillo via inline to compile, link and load C++ code. code &lt;- &#39; arma::mat coeff = Rcpp::as&lt;arma::mat&gt;(a); arma::mat errors = Rcpp::as&lt;arma::mat&gt;(u); int m = errors.n_rows; int n = errors.n_cols; arma::mat simdata(m,n); simdata.row(0) = arma::zeros&lt;arma::mat&gt;(1,n); for (int row=1; row&lt;m; row++) { simdata.row(row) = simdata.row(row-1)*trans(coeff) + errors.row(row); } return Rcpp::wrap(simdata); &#39; ## create the compiled function rcppSim &lt;- cxxfunction(signature(a=&quot;numeric&quot;, u=&quot;numeric&quot;), code, plugin=&quot;RcppArmadillo&quot;) rcppData &lt;- rcppSim(a,u) # generated by C++ code stopifnot(all.equal(rData, rcppData)) # checking results Note: set plugin = \"RcppArmadillo\", while in Chapter 2.2, we set plugin = \"Rcpp\". Comparison suppressMessages(library(rbenchmark)) res&lt;-benchmark(rcppSim(a,u), rSim(a,u), columns=c(&quot;test&quot;, &quot;replications&quot;, &quot;elapsed&quot;, &quot;relative&quot;, &quot;user.self&quot;, &quot;sys.self&quot;), order=&quot;relative&quot;) res ## test replications elapsed relative user.self sys.self ## 1 rcppSim(a, u) 100 0.012 1.00 0.011 0.001 ## 2 rSim(a, u) 100 0.399 33.25 0.393 0.005 "],["tools-and-setup.html", "Chapter 3 Tools and Setup The inline package Rcpp Attributes Exception Handling", " Chapter 3 Tools and Setup The inline package src&lt;-&#39; Rcpp::NumericVector xa(a); Rcpp::NumericVector xb(b); int n_xa = xa.size(), n_xb = xb.size(); Rcpp::NumericVector xab(n_xa + n_xb - 1); for(int i=0; i&lt;n_xa; i++) for(int j=0; j&lt;n_xb; j++) xab[i + j] += xa[i] * xb[j]; return xab; &#39; fun &lt;- cxxfunction(signature(a=&quot;numeric&quot;, b=&quot;numeric&quot;), src,plugin=&quot;Rcpp&quot;) fun( 1:4, 2:5 ) ## [1] 2 7 16 30 34 31 20 The function body is provided by the R character variable src, the function header (and its variables and their names) is defined by the argument signature, and we only need to enable plugin==\"Rcpp\" to obtain a new R function fun based on the C++ code in src. Note: with version 0.3.10 or later of inline, a convenience wrapper rcpp is available which automatically adds the plugin=\"Rcpp\" argument so that the invocation could also have been written as fun &lt;- rcpp(signature(a=\"numeric\", b=\"numeric\"), src) Adding verbose=TRUE shows both the temporary file created by cxxfunction() and the invocations by R CMD SHLIB Through this approah, we do not need to define the input variables a and b in src. Rcpp::NumericVector inc&lt;-&#39; template &lt;typename T&gt; class square : public std::unary_function&lt;T,T&gt; { public: T operator()( T t) const { return t*t ;} }; &#39; src &lt;- &#39; double x = Rcpp::as&lt;double&gt;(xs); int i = Rcpp::as&lt;int&gt;(is); square&lt;double&gt; sqdbl; square&lt;int&gt; sqint; Rcpp::DataFrame df = Rcpp::DataFrame::create(Rcpp::Named(&quot;x&quot;, sqdbl(x)), Rcpp::Named(&quot;i&quot;, sqint(i))); return df; &#39; fun &lt;- cxxfunction(signature(xs=&quot;numeric&quot;, is=&quot;integer&quot;), body=src,include=inc,plugin=&quot;Rcpp&quot;) fun(2.2, 3L) ## x i ## 1 4.84 9 Note: use include to include another block of code to, say, define a new struct or class type. In inc, it defines a sample helper class square which derives from a public class std::unary_function templated to the same argument and return type. In src, it uses square&lt;double&gt; sqdbl and square&lt;int&gt; sqint for two types of variables. Rcpp::DataFrame::create(Rcpp::Named(\"x\", sqdbl(x))) src &lt;- &#39; Rcpp::NumericVector yr(ys) ; Rcpp::NumericMatrix Xr(Xs) ; int n = Xr.nrow(), k = Xr.ncol(); arma::mat X(Xr.begin(), n, k, false) ; arma::colvec y(yr.begin(), yr.size (), false); arma::colvec coef = arma::solve(X, y); // fit y ~ X arma::colvec res = y - X*coef; // residuals double s2 = std::inner_product(res.begin(), res.end(), res.begin(), double())/(n - k); arma::colvec se = arma::sqrt(s2 * arma::diagvec(arma::inv(arma::trans(X)*X))); return Rcpp::List::create(Rcpp::Named(&quot;coef&quot;, coef), Rcpp::Named(&quot;se&quot;) = se, Rcpp::Named(&quot;df&quot;) = n-k); &#39; fun&lt;-cxxfunction(signature(ys=&quot;numeric&quot;, Xs=&quot;numeric&quot;), src, plugin=&quot;RcppArmadillo&quot;) X &lt;- matrix(rnorm(100), nrow = 50) y &lt;- X %*% 1:2 + rnorm(50) fun(ys = y, Xs = X) ## $coef ## [,1] ## [1,] 1.244583 ## [2,] 1.884694 ## ## $se ## [,1] ## [1,] 0.1644080 ## [2,] 0.1455334 ## ## $df ## [1] 48 Note: arma::mat X(Xr.begin(), n, k, false): define a matrix X arma::colvec coef = arma::solve(X, y): solve the regression y ~ X std::inner_product(res.begin(), res.end(), res.begin(), double())/(n - k);: get the variance arma::diagvec(arma::inv(arma::trans(X)*X))): get the diagional elements of \\((X&#39;X)^{-1}\\) Rcpp::List::create(...): create a list Rcpp::Named(\"coef\") = coef is equivalent to Rcpp::Named(\"coef\", coef) Rcpp Attributes cpptxt &lt;- &#39; int fibonacci(const int x) { if (x &lt; 2) return(x); return (fibonacci(x - 1)) + fibonacci(x - 2); }&#39; fibCpp &lt;- cppFunction(cpptxt) Notes “Rcpp attributes” internalizes key features of the inline package while at the same time reusing some of the infrastructure built for use by inline such as the plugins. “Rcpp attributes” adds new functions sourceCpp to source a C++ function (similar to how source is used for R code), cppFunction for a similar creation of a function from a character argument, evalCpp for a direct evaluation of a C++ expression and more. cppFunction returns an R function which calls a wrapper, also created by cppFunction in a temporary file which it also builds. The wrapper function in turn calls the C++ function we passed as a character string. Alternatively, we could pass the name of a file containing the code to the function sourceCpp which would compile, link, and load the corresponding C++ code and assign it to the R function on the left-hand side of the assignment. (see the first example) Exception Handling extern &quot;C&quot; SEXP fun( SEXP x ) { try { int dx = Rcpp::as&lt;int&gt;(x); if (dx &gt; 10) throw std::range_error(&quot;too big&quot;); return Rcpp::wrap(dx * dx); } catch( std::exception&amp; __ex__) { forward_exception_to_r(__ex__); } catch(...) { ::Rf_error( &quot;c++ exception (unknown reason)&quot; ); } return R_NilValue; // not reached } Note: In essence, inside a segment of code preceded by the keyword try, an exception can be thrown via the keyword throw followed by an appropriately typed exception object which is typically inherited from the std::exceptions type. What happens after the throw is that a suitable catch() segment is identified. Here, as the exception was typed with a type inherited from the standard exception, the first branch is the one the code enters. The exception is then passed to an internal Rcpp function which converts it into an R error message. And indeed, at the R level, we see both that an exception was caught and what its type was. src &lt;- &#39; int dx = Rcpp::as&lt;int&gt;(x); if( dx &gt; 10 ) throw std::range_error(&quot;too big&quot;); return Rcpp::wrap( dx * dx); &#39; fun &lt;- cxxfunction(signature(x=&quot;int&quot;), body=src, plugin=&quot;Rcpp&quot;) fun(3) ## [1] 9 # fun(13) # Error in fun(13) : too big "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
