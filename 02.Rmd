# Tools and Setup
```{r echo = FALSE, message = FALSE, warning = FALSE}
library(Rcpp)
library(inline)
library(RcppArmadillo)
setwd("~/Documents/GitHub/Seamless_R_and_Cpp/")
```


## The inline package {-}
```{r}
src<-'
Rcpp::NumericVector xa(a);
Rcpp::NumericVector xb(b);
int n_xa = xa.size(), n_xb = xb.size();

Rcpp::NumericVector xab(n_xa + n_xb - 1);
for(int i=0; i<n_xa; i++)
for(int j=0; j<n_xb; j++)
  xab[i + j] += xa[i] * xb[j];
return xab; 
'
fun <- cxxfunction(signature(a="numeric", b="numeric"),
                   src,plugin="Rcpp") 

fun( 1:4, 2:5 )
```
The function body is provided by the R character variable `src`, the function header (and its variables and their names) is defined by the argument `signature`, and we only need to enable `plugin=="Rcpp"` to obtain a new R function fun based on the C++ code in `src`. 

> Note: 
> 
> 1. with version 0.3.10 or later of `inline`, a convenience wrapper rcpp is available which automatically adds the `plugin="Rcpp"` argument so that the invocation could also have been written as `fun <- rcpp(signature(a="numeric", b="numeric"), src)`
> 2. Adding `verbose=TRUE` shows both the temporary file created by cxxfunction() and the invocations by `R CMD SHLIB`
> 3. Through this approah, we do not need to define the input variables `a` and `b` in `src`. 
> 4. `Rcpp::NumericVector`

```{r}
inc<-'
  template <typename T>
  class square : public std::unary_function<T,T> {
  public:
    T operator()( T t) const { return t*t ;}
  };
'
src <- '
  double x = Rcpp::as<double>(xs);
  int i = Rcpp::as<int>(is);
  square<double> sqdbl;
  square<int> sqint;
  Rcpp::DataFrame df =
    Rcpp::DataFrame::create(Rcpp::Named("x", sqdbl(x)), 
                            Rcpp::Named("i", sqint(i)));
  return df; 
'
fun <- cxxfunction(signature(xs="numeric", is="integer"),
                   body=src,include=inc,plugin="Rcpp")
fun(2.2, 3L)
```

> Note: 
> 
> 1. use `include` to include another block of code to, say, define a new struct or class type.
> 2. In `inc`, it defines a sample helper class `square` which derives from a public class `std::unary_function` templated to the same argument and return type. In `src`, it uses `square<double> sqdbl` and `square<int> sqint` for two types of variables. 
> 4. `Rcpp::DataFrame::create(Rcpp::Named("x", sqdbl(x)))`


```{r}
src <-  '
Rcpp::NumericVector yr(ys) ;
Rcpp::NumericMatrix Xr(Xs) ;
int n = Xr.nrow(), k = Xr.ncol();

arma::mat X(Xr.begin(), n, k, false) ;
arma::colvec y(yr.begin(), yr.size (), false);

arma::colvec coef = arma::solve(X, y);    // fit y ~ X
arma::colvec res = y - X*coef;   // residuals

double s2 = std::inner_product(res.begin(), res.end(), 
                               res.begin(), double())/(n - k);
arma::colvec se = arma::sqrt(s2 * 
                            arma::diagvec(arma::inv(arma::trans(X)*X)));

return Rcpp::List::create(Rcpp::Named("coef", coef), 
                          Rcpp::Named("se")  = se,
                          Rcpp::Named("df")  = n-k);
'
fun<-cxxfunction(signature(ys="numeric", Xs="numeric"),
                 src, plugin="RcppArmadillo")

X <- matrix(rnorm(100), nrow = 50)
y <- X %*% 1:2 + rnorm(50)

fun(ys = y, Xs = X)
```

> Note: 
> 
> 1. `arma::mat X(Xr.begin(), n, k, false)`: define a matrix `X` 
> 2. `arma::colvec coef = arma::solve(X, y)`: solve the regression y ~ X
> 3. `std::inner_product(res.begin(), res.end(), res.begin(), double())/(n - k);`: get the variance
> 4. `arma::diagvec(arma::inv(arma::trans(X)*X)))`: get the diagional elements of $(X'X)^{-1}$
> 5. `Rcpp::List::create(...)`: create a list
> 6. `Rcpp::Named("coef") = coef` is equivalent to `Rcpp::Named("coef", coef)`


## Rcpp Attributes {-}

```{r}
cpptxt <- '
int fibonacci(const int x) {
 if (x < 2) return(x);
 return (fibonacci(x - 1)) + fibonacci(x - 2);
}'

fibCpp <- cppFunction(cpptxt)
```

> Notes
> 
> 1. “Rcpp attributes” internalizes key features of the **inline** package while at the same time reusing some of the infrastructure built for use by inline such as the plugins.
> 2. “Rcpp attributes” adds new functions `sourceCpp` to source a C++ function (similar to how `source` is used for R code), `cppFunction` for a similar creation of a function from a character argument, `evalCpp` for a direct evaluation of a C++ expression and more.
> 3. `cppFunction` returns an R function which calls a **wrapper**, also created by `cppFunction` in a temporary file which it also builds. The wrapper function in turn calls the C++ function we passed as a character string. 
> 4. Alternatively, we could pass the name of a file containing the code to the function `sourceCpp` which would compile, link, and load the corresponding C++ code and assign it to the R function on the left-hand side of the assignment. (see the first example)


## Exception Handling {-}
```{r eval = FALSE}
extern "C" SEXP fun( SEXP x ) { 
  try {
    int dx = Rcpp::as<int>(x);
    if (dx > 10)
      throw std::range_error("too big");
    return Rcpp::wrap(dx * dx);
    } catch( std::exception& __ex__) {
      forward_exception_to_r(__ex__); 
    } catch(...) {
      ::Rf_error( "c++ exception (unknown reason)" ); 
    }
  return R_NilValue; // not reached
}
```

> Note:
> 
> 1. In essence, inside a segment of code preceded by the keyword `try`, an exception can be thrown via the keyword `throw` followed by an appropriately typed exception object which is typically inherited from the `std::exceptions type`. 
> 2. What happens after the `throw` is that a suitable `catch()` segment is identified. Here, as the exception was typed with a type inherited from the standard exception, the first branch is the one the code enters. The exception is then passed to an internal Rcpp function which converts it into an R error message. And indeed, at the R level, we see both that an exception was caught and what its type was.


```{r}
src <- '
int dx = Rcpp::as<int>(x); 
if( dx > 10 )
  throw std::range_error("too big");
return Rcpp::wrap( dx * dx);
'
fun <- cxxfunction(signature(x="int"), body=src, plugin="Rcpp") 
fun(3)
# fun(13)  # Error in fun(13) : too big
```

